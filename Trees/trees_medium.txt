//https://practice.geeksforgeeks.org/problems/sum-of-k-smallest-elements-in-bst3029/1#
//Function to count number of nodes in BST that lie in the given range.
void solve(Node* root,int &cnt,int l,int h)
{
    if(root==NULL)
        return;
    if(root->data>=l&&root->data<=h)
    {
        cnt+=1;
    }
    solve(root->left,cnt,l,h);
    solve(root->right,cnt,l,h);
}
int getCount(Node *root, int l, int h)
{
    if(root==NULL)
        return 0;
    int cnt = 0;
    solve(root,cnt,l,h);
    return cnt;
  // your code goes here   
}


//https://practice.geeksforgeeks.org/problems/add-all-greater-values-to-every-node-in-a-bst/1
void solve(Node* root,int &sum)
{
    if(root==NULL)
        return;
    solve(root->right,sum);
    sum+=root->data;
    root->data=sum;
    solve(root->left,sum);
}
Node* modify(Node *root)
{
    if(root==NULL)
        return NULL;
    int sum = 0;
    solve(root,sum);
    return root;
    // Your code here
}

//https://practice.geeksforgeeks.org/problems/tree-from-postorder-and-inorder/1
Node* solve(int in[],int post[],int s,int e,int &i,unordered_map<int,int> &mp)
{
    if(s>e)
        return NULL;
        
    int curr = post[i];
    i--;
    Node* node = new Node(curr);
    if(s==e)
    {
        return node;
    }
    int idx = mp[curr];
    node->right = solve(in,post,idx+1,e,i,mp);
    node->left = solve(in,post,s,idx-1,i,mp);
    return node;
}
Node *buildTree(int in[], int post[], int n) {
    unordered_map<int,int> mp;
    for(int i=0;i<n;i++)
    {
        mp[in[i]]=i;
    }
    int i=n-1;
    return solve(in,post,0,n-1,i,mp);
    // Your code here
}

//Sum tree
https://practice.geeksforgeeks.org/problems/sum-tree/1
    int sum(Node* root)
    {
        if(root==NULL)
            return 0;
        return root->data+sum(root->left)+sum(root->right);
    }
    void solve(Node* root,bool &res)
    {
        if(root==NULL)
            return;
        if(root->left==NULL&&root->right==NULL)
            return;
        int lt = sum(root->left);
        int lr = sum(root->right);
        if(lt+lr!=root->data)
        {
            res=false;return;
        }
        solve(root->left,res);
        solve(root->right,res);
    }
    bool isSumTree(Node* root)
    {
        if(root==NULL)
            return true;
        bool res = true;
        solve(root,res);
        return res;
         // Your code here
    }


//https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1
vector<vector<Node*>> levelOrder(Node *root)
{
    vector<vector<Node*>> vp;
    if (root == NULL)
        return vp;

    queue<Node *> q;
    q.push(root);
    while (!q.empty())
    {
        vector<Node*> t;
        int sz = q.size();
        for (int i = 0; i < sz; i++)
        {
            Node *temp = q.front();
            // cout<<temp->val<<" ";
            q.pop();
            if (temp->left != NULL)
            {
                q.push(temp->left);
            }
            if (temp->right != NULL)
            {
                q.push(temp->right);
            }
            t.push_back(temp);
        }
       
        vp.push_back(t);
    }
    return vp;
}
    void connect(Node *root)
    {
        vector<vector<Node*>> vp = levelOrder(root);
        for(auto &value:vp)
        {
            for(int i=0;i<value.size()-1;i++)
            {
                value[i]->nextRight=value[i+1];
            }
            value[value.size()-1]->nextRight=NULL;
        }
        
       // Your Code Here
    } 

//https://practice.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-binary-tree/1#
    void solve(Node* root,bool &flag,vector<int> &vp,int x)
    {
        if(root==NULL)
            return;

        if(root->data==x)
        {
            flag = true;
        }
        
        if(!flag)
        {
            solve(root->left,flag,vp,x);
        }
        if(!flag)
        {
            solve(root->right,flag,vp,x);
        }
        if(flag)
        {
            vp.push_back(root->data);
        }
        
    }
    Node* lca(Node* root ,int n1 ,int n2 )
    {
        if(root==NULL)
            return NULL;
        vector<int> p1;
        bool flag = false;
        solve(root,flag,p1,n1);
        flag = false;
        vector<int> p2;
        solve(root,flag,p2,n2);
        if(p1.size()==0&&p2.size()==0)
        {
            return new Node(-1);
        }
        // for(auto &value:p1)
        //     cout<<value<<" ";
        // cout<<endl;
        // for(auto &value:p2)
        //     cout<<value<<" ";
        // cout<<endl;
        int ans = -1;
        unordered_set<int> s;
        for(auto &value:p1)
            s.insert(value);
        for(auto &value:p2)
        {
            if(s.find(value)!=s.end())
            {
                ans=value;break;
            }
        }
        return new Node(ans);
       //Your code here 
    }

//https://practice.geeksforgeeks.org/problems/maximum-difference-between-node-and-its-ancestor/1#
int solve(Node* root,int &ans)
{
    if(root==NULL)
        return INT_MAX;
    
    if(root->left==NULL&&root->right==NULL)
        return root->data;
    int l = solve(root->left,ans);
    int r = solve(root->right,ans);
    int ok = min(l,r);
    ans=max(ans,root->data-ok);
    return min(root->data,ok);
}
int maxDiff(Node* root)
{
    int ans = INT_MIN;
    solve(root,ans);
    return ans;
    // Your code here 
}

//https://practice.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/1#
    void solve(Node* root,int cnt,int l,map<int,map<int,vector<int>>> &mp)
    {
        if(root==NULL)
            return;
        mp[cnt][l].push_back(root->data);
        solve(root->left,cnt-1,l+1,mp);
        solve(root->right,cnt+1,l+1,mp);
        
    }
    vector<int> verticalOrder(Node *root)
    {
        vector<int> ans;
        if(root==NULL)
            return ans;
        map<int,map<int,vector<int>>> mp;
        solve(root,0,0,mp);
        
        for(auto &value:mp)
        {
            for(auto &val:value.second)
            {
                for(auto &val2:val.second)
                {
                    ans.push_back(val2);
                }
            }
            
        }
        return ans;
        //Your code here
    }

//Serialise and deserialise a tree
    void construct(Node* root,vector<int> &ok)
    {
        if(root==NULL)  
        {
            ok.push_back(-1);
            return;
        }
        ok.push_back(root->data);
        construct(root->left,ok);
        construct(root->right,ok);
    }
    vector<int> serialize(Node *root) 
    {
        vector<int> ans;
        if(root==NULL)
            return ans;
        construct(root,ans);
        // for(auto &value:ans)
        //     cout<<value<<" ok";
        // cout<<endl;
        return ans;
        //Your code here
    }
    
    //Function to deserialize a list and construct the tree.
    Node* solve(vector<int> &A,int &idx)
    {
        if(idx>=A.size()||A[idx]==-1)
        {
            idx++;
            return NULL;
        }
        Node* root = new Node(A[idx++]);
      
        root->left=solve(A,idx);
       
        root->right=solve(A,idx);
        return root;
    }
    Node * deSerialize(vector<int> &A)
    {
        if(A[0]==-1)
            return NULL;
        int idx = 0;

        return solve(A,idx);
       //Your code here
    }