// Based on inorder traversal
//https://practice.geeksforgeeks.org/problems/print-bst-elements-in-given-range/1#
  vector<int> ans;
    vector<int> printNearNodes(Node *root, int low, int high) {
        if(root==NULL)
            return ans;
        

        printNearNodes(root->left,low,high);

        if(root->data>=low&&root->data<=high)
        {
            ans.push_back(root->data);
        }
        
        printNearNodes(root->right,low,high);
        
        return ans;
        //code here   
    }

//BT to bst
 Node* insert(Node* root, int Key) {
    Node* node = new Node(Key);
    if(root==NULL)
        return node;
    
    if(Key<root->data)
    {
        if(root->left)
        {
            insert(root->left,Key);
        }
        else
            root->left=node;
    }
    else if(Key>root->data)
    {
        if(root->right)
        {
            insert(root->right,Key);
        }
        else
        {
            root->right=node;
        }
    }
    return root;
    // Your code here
}
    // The given root is the root of the Binary Tree
    // Return the root of the generated BST
    void solve(Node *root,Node* newroot)
    {
        if(root==NULL)
            return;
        newroot = insert(newroot,root->data);
        solve(root->left,newroot);
        solve(root->right,newroot);
        return;
    }
    Node *binaryTreeToBST (Node *node)
    {
    
        if(root==NULL)
            return NULL;
        Node* newroot = NULL;
        solve(root,newroot);
       
        return newroot;
        //Your code goes here
    }

// Leaf at same level
    int height(Node* root)
    {
        if(root==NULL)
            return 0;
        return 1+max(height(root->left),height(root->right));
    }
    
    bool check(Node *root)
    {
        if(root==NULL)
            return true;
        
        if(root->left&&root->right&&height(root->left)!=height(root->right))
        {
            return false;
        }
        return check(root->left)&&check(root->right);
        //Your code here
    }

//
https://practice.geeksforgeeks.org/problems/is-binary-tree-heap/1

     int height(Node* root)
    {
        if(root==NULL)
            return 0;
        return 1+max(height(root->left),height(root->right));
    }
    bool isHeap(struct Node* root) {
        if(root==NULL)
            return true;
        
        if(root->left&&root->right&&height(root->left)!=height(root->right))
        {
            return false;
        }
        if(root->left&&root->right&&(root->data<root->left->data||root->data<root->right->data))
        {
            return false;
        }
        return isHeap(root->left)&&isHeap(root->right);
        // code here
    }